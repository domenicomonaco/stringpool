{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Stringpool  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Stringpool}
{\comment Generato daDoxgyen. }
{\creatim \yr2011\mo5\dy30\hr10\min9\sec24}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sommario\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indice dei tipi composti\par \pard\plain 
{\tc \v Indice dei tipi composti}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Elenco dei tipi composti\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Queste sono le classi, le struct, le union e le interfacce con una loro breve descrizione:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b string} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b stringpool} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indice dei file\par \pard\plain 
{\tc \v Indice dei file}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Elenco dei file\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Questo \'E8 un elenco di tutti i file con una loro breve descrizione:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b cunit_stringpool_lib/src/{\b cunit_stringpool_lib.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File per il testing della libreria stringpool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Library/{\b bool.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per valori Booleani })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Library/{\b spstring.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementazione funzioni stringpool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Library/{\b spstring.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per funzioni stringpool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Library/{\b stringpool.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per tipi di dati stringpool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documentazione delle classi{\tc \v Documentazione delle classi}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per la struct string\par \pard\plain 
{\tc\tcl2 \v string}
{\xe \v string}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
{
{\f2 #include <stringpool.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Attributi pubblici\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b char_array}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b allocated_size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tipo di dato non primitivo string Insieme di caratteri da allocare dinamicamente, contiene anche un contatore della sua dimensione \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione dei membri dato\par
\pard\plain 
{\xe \v allocated_size\:string}
{\xe \v string\:allocated_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b string::allocated_size}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contiene la dimensione massima allocata per tale string, se N>0 allora \'8F possibile inserire N-1 Caratteri con carattere di terminazione \\0 in posizione N. \par
}}
{\xe \v char_array\:string}
{\xe \v string\:char_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b string::char_array}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vettore a caratteri caratteri tramite puntatore a caratteri, rappresenta il contenuto della stringa \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentazione per questa struct \'E8 stata generata a partire dal seguente file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Library/{\b stringpool.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per la struct stringpool\par \pard\plain 
{\tc\tcl2 \v stringpool}
{\xe \v stringpool}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\par
{
{\f2 #include <stringpool.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Attributi pubblici\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b strings} [MAX_DIM_STRING_POOL]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b used_counter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b positions} [MAX_DIM_STRING_POOL]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tipo di dato non primitivo stringpool Insieme dinamico di elementi di tipo string, contiene anche il numero e la posizione degli slot occupati. Il numero di slot che stringpool pu\'98 contenere \'8F definito da MAX_DIM_STRING_POOL. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione dei membri dato\par
\pard\plain 
{\xe \v positions\:stringpool}
{\xe \v stringpool\:positions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b stringpool::positions}[MAX_DIM_STRING_POOL]}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array per identificare quali posizioni sono occupati o libere \par
}}
{\xe \v strings\:stringpool}
{\xe \v stringpool\:strings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* {\b stringpool::strings}[MAX_DIM_STRING_POOL]}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array a puntatori di tipo stringa, rappresentano gli slot di stringpool \par
}}
{\xe \v used_counter\:stringpool}
{\xe \v stringpool\:used_counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b stringpool::used_counter}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contatore delle locazioni utilizzate \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentazione per questa struct \'E8 stata generata a partire dal seguente file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Library/{\b stringpool.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documentazione dei file{\tc \v Documentazione dei file}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per il file cunit_stringpool_lib/src/cunit_stringpool_lib.c\par \pard\plain 
{\tc\tcl2 \v cunit_stringpool_lib/src/cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib/src/cunit_stringpool_lib.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File per il testing della libreria stringpool. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "CUnit/Basic.h"}\par
{\f2 #include "bool.h"}\par
{\f2 #include "stringpool.h"}\par
{\f2 #include "spstring.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funzioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b suite_void_init_func} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b suite_void_cleanup_func} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b suite_init_func} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b suite_cleanup_func} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_initialize_stringpool} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_new_empty_string} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_new_string} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_get_allocated_size} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_free} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_strlen} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_strcmp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_strcpy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_strcat} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_lower_case} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_upper_case} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_add_string} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_get_string} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_add_string_pos} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_remove_string} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_replace_string} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_find_string} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_isfull} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_isempty} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_sizeof} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_free_stringpool} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_strcat_as_struct} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_strcat_as_struct. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_save_to_file} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_save_to_file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_load_from_file} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_load_from_file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_bubble_sort} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_bubble_sor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_bin_search} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_bin_search. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_file_exist_create} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per _sp_file_exist _sp_file_create. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_sp_map_array_stringpool} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per _sp_map_array_stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variabili\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b stringpool} {\b sp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b CONST_TEST_STRING_LOWER_CASE} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b CONST_TEST_STRING_UPPER_CASE} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CONST_TEST_STRING_LEN}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File per il testing della libreria stringpool. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2011 \par
}{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Licenza
\par}
{\tc\tcl2 \v Licenza}
GPLv2 {\f2 http://www.softwarelibero.it/gnudoc/gpl.it.txt} Per maggiori informazioni visitare il link o visualizzare il file LICENSE \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle funzioni\par
\pard\plain 
{\xe \v main\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int{\i argc}, char *{\i argv}[])}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suite_cleanup_func\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:suite_cleanup_func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int suite_cleanup_func (void)}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suite_init_func\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:suite_init_func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int suite_init_func (void)}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suite_void_cleanup_func\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:suite_void_cleanup_func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int suite_void_cleanup_func (void)}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suite_void_init_func\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:suite_void_init_func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int suite_void_init_func (void)}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_add_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_add_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_add_string (void)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_add_string_pos\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_add_string_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_add_string_pos (void)}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_bin_search\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_bin_search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_bin_search (void)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_bin_search. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare la ricerca binaria in concomitanza del bubble sort\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controllo che sp sia vuoto\par
Inserisco in ordine casuale 6 stringhe\par
Ne rimuovo una in posizione 3, Ragusa\par
Ricontrollo la dimensione\par
Ordino l'array, \'8F una specifica per il binary search\par
Dopo l'ordinamento mi aspetto che sp sia ordinato in questo modo: Colombo Domenico Flickr Google Monaco\par
Effettuo una prima ricerca sul valore elimnato e mi aspetto di riceve errore\par
Controllo che le posizioni degli elementi sia quella che mi aspetto \par
}}\par
}
{\xe \v test_sp_bubble_sort\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_bubble_sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_bubble_sort (void)}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_bubble_sor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare l'ordinamento con bubble sort conservando posizioni vuote/piene\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro ed inizializzo un nuovo nome di file da leggere, sempre che esista\par
Carichiamo da file e controlliamo che il numero di righe caricate corrisponda alla dimensione di sp e che sp sia della dimensione che ci aspettiamo\par
Ho ordinato le 4 frasi con gEdit e mi aspetto che esse siano nel seguente ordine\par
Ci aspettiamo che anche dopo l'ordinamente la posizione 3 sia NULL \par
}}\par
}
{\xe \v test_sp_file_exist_create\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_file_exist_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_file_exist_create (void)}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per _sp_file_exist _sp_file_create. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare le funzioni per creare file e controllare se esite gi\'88 il file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro e creo la variabile per il nome del file\par
Controllo se esiste\par
Cerco di crearlo\par
Ricontrollo se esiste\par
Rimuovo il file\par
Rimuovo il file\par
Controllo se esiste un file NULL\par
Dichiaro un nome di file pre-esistenbte\par
Controlliamo se esiste\par
Controlliamo se possiamo sovrascriverlo \par
}}\par
}
{\xe \v test_sp_find_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_find_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_find_string (void)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_free\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_free ()}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_free_stringpool\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_free_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_free_stringpool (void)}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_get_allocated_size\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_get_allocated_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_get_allocated_size ()}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_get_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_get_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_get_string (void)}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_initialize_stringpool\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_initialize_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_initialize_stringpool ()}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_isempty\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_isempty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_isempty (void)}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_isfull\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_isfull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_isfull (void)}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_load_from_file\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_load_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_load_from_file (void)}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_load_from_file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare il caricamento da file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Credo la string con il nome del file da caricare, \'8F stato creato nel test precedente\par
Controlliamo che sp sia vuoto, ricever\'88 in ingresso le righe del file letto\par
Controlliamo che il caricamento ritorni il numero di righe della dimensione di sp\par
Controllo se le stringhe caricate sono esattamente quelle che avevo scritto su file e nella loro posizione\par
Rimuovo le stringhe da sp\par
Controllo che sp sia vuoto\par
Dichiaro ed inizializzo un nuovo nome di file da leggere, sempre che esista\par
Carichiamo da file e controlliamo che il numero di righe caricate corrisponda alla dimensione di sp e che sp sia della dimensione che ci aspettiamo\par
Controlliamo che il caricamento in posizioni non contigue sia andato a buon fine\par
Ci aspettiam che la posizione 3 sia NULL \par
}}\par
}
{\xe \v test_sp_lower_case\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_lower_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_lower_case ()}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_map_array_stringpool\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_map_array_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_map_array_stringpool (void)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per _sp_map_array_stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare la creazione della mappa di stringpool\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controllo che sp sia vuoto\par
Inseriamo a salti alcuni elemnti in sp\par
Ricontrollo la dimensione\par
Controlleremo in modo "consecutivo" le posizioni sp ignorando le posizoni reali, Controllando passo per passo elementi consecuitivi, il primo elemento, il secondo ecc...\par
Il termine Drupal \'8F in posizione reale 0 ed in posizione virtuale map_array 0. In entrambi i casi \'8F il primo elemento.\par
Il termine Django \'8F in posizione reale 2 ed in posizione virtuale map_array 1. In entrambi i casi \'8F il Secondo elemento.\par
Il termine Wordpress \'8F in posizione reale 3 ed in posizione virtuale map_array 2. In entrambi i casi \'8F il Terzo elemento.\par
Il termine Php \'8F in posizione reale 5 ed in posizione virtuale map_array 3. In entrambi i casi \'8F il Quarto elemento.\par
Il termine Magento \'8F in posizione reale 7 ed in posizione virtuale map_array 4. In entrambi i casi \'8F il Quinto elemento.\par
Il termine Python \'8F in posizione reale 8 ed in posizione virtuale map_array 5. In entrambi i casi \'8F il Sesto elemento.\par
Controlliamo immettendo direttamente le posizioni reali \par
}}\par
}
{\xe \v test_sp_new_empty_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_new_empty_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_new_empty_string ()}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_new_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_new_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_new_string ()}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_remove_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_remove_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_remove_string (void)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_replace_string\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_replace_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_replace_string (void)}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_save_to_file\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_save_to_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_save_to_file (void)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_save_to_file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto per testare il salvataggio su file {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro il puntare a string per il nome dle file\par
Ci assicuriamo che sia vuoto sp\par
Aggiungiamo 5 string a sp, possibilmente con spazi per verificare se la scrittura di frasi con spazi funziona\par
Creiamo uno spazio vuoto eliminando la string in posizione 3\par
Controlliamo se in prima posizine abbimo il nome del file\par
Controlliamo che sia di dimensione 4\par
Controlliamo che la dimensione di sp corrisponda al numero di righe scritte\par
Rimuoviamo le stringhe scritte\par
Controlliamo che sp sia vuoto\par
Creiamo una stringa con il nome del file senza metterlo in sp\par
Aggiungiamo le stringhe in sp, miste con spazi, numeri e simboli speciali\par
Verifichiamo la dimensione di sp\par
Verifichiamo che la dimensioni di sp corrisponda al numero di righe scritte\par
Liberiamo sp dalle righe scritte, svuotandolo\par
Verifichiamo che sia vuoto\par
Scriviamo un file vuoto\par
Non dovrebbe scrivere nessun file e ritornare errore -1 a causa del nome sbagliato del file\par
Non dovrebbe scrivere nessun file e ritornare errore -1 a causa del nome sbagliato del file\par
Non dovrebbe scrivere nessun file e ritornare errore -1 a causa del puntatore a sp NULL \par
}}\par
}
{\xe \v test_sp_sizeof\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_sizeof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_sizeof (void)}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_strcat\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_strcat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_strcat ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_strcat_as_struct\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_strcat_as_struct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
test_sp_strcat_as_struct ()}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test per sp_strcat_as_struct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Caso di test aggiunto in string_manipulation {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}}
{\xe \v test_sp_strcmp\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_strcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_strcmp ()}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_strcpy\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_strcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_strcpy ()}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_strlen\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_strlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_strlen ()}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test_sp_upper_case\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:test_sp_upper_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_sp_upper_case ()}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle variabili\par
\pard\plain 
{\xe \v CONST_TEST_STRING_LEN\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:CONST_TEST_STRING_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b CONST_TEST_STRING_LEN}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CONST_TEST_STRING_LOWER_CASE\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:CONST_TEST_STRING_LOWER_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* {\b CONST_TEST_STRING_LOWER_CASE} = NULL}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CONST_TEST_STRING_UPPER_CASE\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:CONST_TEST_STRING_UPPER_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* {\b CONST_TEST_STRING_UPPER_CASE} = NULL}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sp\:cunit_stringpool_lib.c}
{\xe \v cunit_stringpool_lib.c\:sp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b stringpool} {\b sp}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per il file Library/bool.h\par \pard\plain 
{\tc\tcl2 \v Library/bool.h}
{\xe \v Library/bool.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per valori Booleani. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definizioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOLE_H_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipi enumerati (enum)\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b boolean} \{ {\b FALSE} =  0, 
{\b TRUE} =  1
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tipo di dato non primitivo boolean. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per valori Booleani. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Autore:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Domenico Monaco, {\f2 domenico.monaco@kiuz.it} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2011 \par
}{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Licenza
\par}
{\tc\tcl2 \v Licenza}
GPLv2 {\f2 http://www.softwarelibero.it/gnudoc/gpl.it.txt} Per maggiori informazioni visitare il link o visualizzare il file LICENSE \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle definizioni\par
\pard\plain 
{\xe \v BOOLE_H_\:bool.h}
{\xe \v bool.h\:BOOLE_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOLE_H_}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Impedisce inclusioni multiple \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione dei tipi enumerati\par
\pard\plain 
{\xe \v boolean\:bool.h}
{\xe \v bool.h\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum Definizione del tipo {\b boolean}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tipo di dato non primitivo boolean. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
vale 1 se TRUE, 0 se FALSE \par
}{{{\b Valori del tipo enumerato: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v FALSE\:bool.h}
{\xe \v bool.h\:FALSE}
{\b {\i FALSE{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
valore boolean FALSE = 0 \par
}{\xe \v TRUE\:bool.h}
{\xe \v bool.h\:TRUE}
{\b {\i TRUE{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
valore boolean TRUE = 1 \par
}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per il file Library/spstring.c\par \pard\plain 
{\tc\tcl2 \v Library/spstring.c}
{\xe \v Library/spstring.c}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementazione funzioni stringpool. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <ctype.h>}\par
{\f2 #include "bool.h"}\par
{\f2 #include "stringpool.h"}\par
{\f2 #include "spstring.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funzioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_initialize_stringpool} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inizializza una struttura Stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_free} ({\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dealloca lo spazio di memoria a cui sta puntando str. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_free_stringpool} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Libera la memoria e reinizializza la struct sringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_empty_string} (int len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string vuota di dimensione len. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_string} (const char *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string con contenuto pari a quello in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_get_allocated_size} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce la dimensione massima allocata per la stringa. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_strlen} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcola e restituisce la lunghezza logica di una string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_strcmp} (const {\b string} *str1, const char *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Confronta due stringhe e restituisce il relativo valore di verit\'88 }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_string_as_struct} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una nuova string il cui contenuto \'8F uguale a quella in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcpy} ({\b string} *copy, const char *original, int offset)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia il contenuto della string original in copy. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcat} (const char *str1, const char *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla concatenazione di due stringhe in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcat_as_struct} (const {\b string} *str1, const {\b string} *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla conctaenazione delle due string in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_lower_case} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in minuscolo ciascun carattere della stringa in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_upper_case} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in maiuscolo ciascun carattere della stringa in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_isempty} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se lo stringpool \'8F vuoto. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_isfull} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se stringpool contiene gi\'88 il massimo numero di elementi consentiti. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_add_string_pos} ({\b stringpool} *{\b sp}, {\b string} *str, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge una string all\'D5interno dello stringpool in posizione pos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_add_string} ({\b stringpool} *{\b sp}, {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge la stringa puntata da str all\'D5interno dello stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_sizeof} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il numero di stringhe in sp. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_get_string} (const {\b stringpool} *{\b sp}, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il puntatore alla stringa str che occupa la posizione pos all\'D5interno dello stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_remove_string} ({\b stringpool} *{\b sp}, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rimuove e restituisce la stringa str all\'D5interno dello stringpool in posizione pos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_replace_string} ({\b stringpool} *{\b sp}, int pos, {\b string} *newstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sostituisce la stringa all\'D5interno dello stringpool in posizione pos, rimpiazzandola con str. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_save_to_file} ({\b stringpool} *{\b sp}, const {\b string} fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Salva il contenuto dello stringpool in un file di testo. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_load_from_file} ({\b stringpool} *{\b sp}, const {\b string} fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Carica il contenuto del file di test fname nello o stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bubble_sort} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina alfabeticamente gli elementi dello stringpool, applicando l\'D5algoritmo di bubble sort. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bin_search} (const {\b stringpool} *{\b sp}, const {\b string} str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool ordinato attraverso l\'D5algoritmo di ricerca binaria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_find_string} (const {\b stringpool} *{\b sp}, const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool e ne restituisce la posizione, nel caso sia presente. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b _sp_file_exist} (const {\b string} *fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se il file richiesto esiste e ne restituisce il valore di verit\'88 }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b _sp_file_create} (const {\b string} *fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se esiste gi\'88 il file e se non esiste lo crea. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b _sp_map_array_stringpool} (const {\b stringpool} *{\b sp})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementazione funzioni stringpool. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
La libreria stringpool consente la gestione di un'insieme di dati di tipo string. Due sono i tipi di dato gestiti: string, stringpool.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Autore:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Domenico Monaco, {\f2 domenico.monaco@kiuz.it} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2011 \par
}{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Licenza
\par}
{\tc\tcl2 \v Licenza}
GPLv2 {\f2 http://www.softwarelibero.it/gnudoc/gpl.it.txt} Per maggiori informazioni visitare il link o visualizzare il file LICENSE \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle funzioni\par
\pard\plain 
{\xe \v _sp_file_create\:spstring.c}
{\xe \v spstring.c\:_sp_file_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_sp_file_create (const {\b string} *{\i fname})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se esiste gi\'88 il file e se non esiste lo crea. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifcreated boolean valore di verit\'88, TRUE se \'8F esiste gi\'88 o se non esiste ed \'8F stato Creato, FALSE se non esiste non \'8F stato possibile crearlo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Dichiaro il puntatore a file\par
Verifico che fname non sia nullo\par
Controllo se non esiste gi\'88 il file\par
Se non esiste cerco di crearlo\par
Se non si riesce a a crearlo imposto la variabile di output a FALSE\par
Altrimenti se sono riuscito* a crerlo imposto la variabile di output a TRUE\par
Chiudo il file aperto\par
Se esiste gi\'88 imposto la variabile outpt a TRUE\par
Ritorno il valore di output \par
}}\par
}
{\xe \v _sp_file_exist\:spstring.c}
{\xe \v spstring.c\:_sp_file_exist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_sp_file_exist (const {\b string} *{\i fname})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se il file richiesto esiste e ne restituisce il valore di verit\'88 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifexist valore boolean FALSE se non esiste non \'8F possibile aprirlo in modalit\'88 di lettura, TRUE se esiste ed \'8F possibile aprirlo in modalit\'88 di lettura \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output inizializzandola a FAlSE\par
Dichiaro il puntatore a file\par
Verifico che fname non sia nullo\par
Controllo se \'8F possibile aprire il file richiesto in modalit\'88 di lettura\par
Se non \'8F possibile aprirlo imposto la variabile di output a FALSE\par
Altrimenti se \'8F possibile aprie il file imposto a TRUE la variabile di output\par
Chiudo il file\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v _sp_map_array_stringpool\:spstring.c}
{\xe \v spstring.c\:_sp_map_array_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int* _sp_map_array_stringpool (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro l'array di output\par
Dichiaro la variabile indice per il ciclo for e la variabile di posizione\par
Controllo che sp non sia NULL\par
Inizializzo lo spazio di memoria per l'array di outpu calcolato sulla dimensione di sp\par
Itero su tutte le possibili posizioni potenzialmente occupate in sp\par
Controllo se la i-esima posizione \'8F occupata\par
In caso sia occupata salvo in posizioni consecutive la posizione i-esima\par
Incremento la posizione del vettore di output solo se \'8F stato inserito qualcosa\par
Ritorno la varibile di ouput \par
}}\par
}
{\xe \v bin_search\:spstring.c}
{\xe \v spstring.c\:bin_search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bin_search (const {\b stringpool} *{\i sp}, const {\b string}{\i str})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool ordinato attraverso l\'D5algoritmo di ricerca binaria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ne restituisce la posizione, nel caso in cui str sia presente.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i \\return} \cell }{iffound pari alla posizione p della stringa, con 0<= p < MAX_DIM_STRING_POOL se str \'8F presente in sp; p=-1, altrimenti. Se sp o str sono nulli, restituisce -1. \cell }
{\row }
}
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Dichiaro la variabile indice per il ciclo while della ricerca binaria, rappresenta il numero di controll effettuati\par
Variabile di controllo per la ricerca della stringa cercata\par
Variabili per il calcolo dell'i-esima posizione da controlla come da definizione del bin_search\par
Puntatore ad array di interi contenere la mappa delle posizioni degli slot in stringpool\par
Controllo che sp e str non siano NULL, altrimenti salta salta e restituisce valore di errore -1\par
Calcolo e salvo la dimensione di sp\par
Se ha dimensione diversa da 0 \'8F possibile effettuare la ricerca\par
Ottengo la mappa delle posizione degli slot di sp\par
Imposto il parametro hight del binary serch alla dimensione di sp\par
Imposoto il parametro low del binary search a 1\par
Itero finch\'8F str_cmp non \'8F 0 ovvero \'8F stata identificata esattamente la stringa ricercata oppure se abbiamo gi\'88 controllato tutto gli slot\par
Calcolo mid su base della formula binary search\par
Controllo la strina in posizione mid, contrale rispetto [low, hight]\par
In base al risultato associo a low o hight un valore diverso ed incremento la variabile indice\par
Alla fine dll'iterazione controllo controllo se sia stata identificata o meno la stringa righesta\par
In caso sia concluso il ciclo senza trovare la stringa o non sia neanche iniziato, imposto il risultato a -1\par
In caso invece sia stata identificata la stringa resituisco la sua posizione\par
Ritorno il valore di ritorno che pu\'98 essere o la posizione p della strnga cercata o -1 in caso di errore \par
}}\par
}
{\xe \v bubble_sort\:spstring.c}
{\xe \v spstring.c\:bubble_sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bubble_sort ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina alfabeticamente gli elementi dello stringpool, applicando l\'D5algoritmo di bubble sort. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina effettuando un controllo su ogni coppia di elementi, partendo dal basso sceglie minore del confronto e lo porta verso l'alto. Ho usato la versione "corta" dell'algoritmo dover per ogni i-esimo ciclo assumiamo che l'elemento appena spostato \'8F gi\'88 in posizione corretta. Ho dovuto applicare un piccolo hack per poter fare l'ordinamento anche su array con elementi non contiugui e lasciare invariate le posizione vuote, in altri termini l'algoritmo ordina gli elementi solo sulle posizione attualmente utilizzare senza alterare la posizione degli slot vuoti.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro le variabili indici per i due cicli dell'algoritmo Bubble sort\par
Dichiaro la variabile per identificare se nell'i-esimo controllo \'8F necessario uno Switch degli slot\par
Dichiaro la variabile per memorizzare temporaneamente la string da sostituire\par
Dichiaro la variabile per mappare le posizioni degli slot\par
Controllo prima se sp non sia NULL ed in seguito se sp non \'8F VUOTO altrimenti non faccio null\par
Ottengo un array della mappa delle posizione dell'array. Dove ogni i-esima posione contiene la posizione reale dello slot. Ad esempio se esistono 4 elementi, ma il sp->position[3] \'8F vuoto mentre il sp->position[4] \'8F pieno il risultato sar\'88 un arrai del tipo [0->0,1->1,2->2,3->4]\par
Itero su due cicli for come da definizione dell'algoritmo\par
Il primo ciclo itera da 0 alla dimensione di sp, incrementando il puntatore\par
Il secondo ciclo itera dalla dimensione di sp meno 1,fino ad i, decrementando l'indice.\par
Ad ogni iterazione del primo ciclo for, il secndo ciclo for effettuera un passaggio in meno evitando di controllare elementi sicuramente gi\'88 in posizione corretta\par
La j esima posione \'8F quella corrente e dipende anche da i. Controlliamo le poszioni (j) e (j-1), identificando se sono o meno in ordine alfabetico utilizzando strcmp. Quindi ifswitch sar\'88 -1 l'elemento j deve essere spostato in posizione j-1 e viceversa\par
In questi cicli non mi devo preoccupare dei "buchi" nell'array stringpool dato che le iterazioni sono fatte sulla mappa dele posizione che \'8F un array continuo che ci permette di tradurre per ogni iterazione la reale posizione dello slot trattato\par
Controllo se bisogna scambiare gli elementi\par
Memorizzo temporanemente la stringa in posizione j\par
Rimpiazzo in posizione j la strin j-1\par
Rimpiazzo in posizione j-1 la stringa memorizzata precedentemente, ovvero quella in posizione j \par
}}\par
}
{\xe \v sp_add_string\:spstring.c}
{\xe \v spstring.c\:sp_add_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_add_string ({\b stringpool} *{\i sp}, {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge la stringa puntata da str all\'D5interno dello stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Viene aggiunta nella prima posizione libera. Nessuna operazione \'8F compiuta se str e/o sp sono nulli, oppure se sp \'8F pieno.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_added TRUE se l\'D5inserimento \'8F andato a buon fine, FALSE altrimenti. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di outpu inizializzandola a FALSE\par
Dichiaro la varibile di verit\'88 per la posizione libera\par
Variabile indice per ciclo while per la ricerca della posizione libera\par
Variabile\par
Controllo che sp ed str non siano NULL\par
Controllo se lo string pool non \'8F pieno\par
Ciclo per l'intero stringpool alla ricerca della prima posizione libera\par
Il ciclo continua finch\'8F check_free \'8F diverso da 1 e non abbiamo controllato tutte le posizini\par
Per ogni ciclo controllo se l'i-esima posizione \'8F libera\par
In caso affermativo, imposto check_free a 1\par
Provo quindi ad aggiungere la string in ingresso nella posizione libera appena trovata\par
Memoriazando il risutlato di tale operazione\par
Controllo se l'operazione di aggiunta della string in posizine iesima \'8F andata a buon fine\par
In caso affermativo imposto la variabile di output a TRUE\par
In caso negativo, riporto check_free a 0 permettendo di continuare a cercare un'altra posizione\par
Incremente il contatore iesimo\par
Ritorno il valore di verit\'88 per l'operazione di aggiunta string \par
}}\par
}
{\xe \v sp_add_string_pos\:spstring.c}
{\xe \v spstring.c\:sp_add_string_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_add_string_pos ({\b stringpool} *{\i sp}, {\b string} *{\i str}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge una string all\'D5interno dello stringpool in posizione pos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se str e/o sp sono nulli, se pos \'8F fuori dall\'D5intervallo 0<= pos < MAX_DIM_STRING_POOL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero che indica la posizione in cui aggiungere la string\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_added vale TRUE se l\'D5inserimento \'8F andato a buon fine, FALSE altrimenti. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output inizializzandola a FALSE\par
Controllo che sp e str non siano null e controllo che la posizione richiesta esista nello stringpool\par
Controllo che la posizione pos sia gi\'88 occupata, in tal caso libero la memoria\par
Inesrisco in strings[pos] il puntatore a str passata\par
positions e used_counter sono aggiornati solo se \'8F realmente presente in strings[pos] l'indirizzo voluto, altrimenti non aggiorna le variabili\par
L'assocciazione \'8F andata a buon fine, posso aggiornare le variabili positions, used_counter e is_added per l'output\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v sp_find_string\:spstring.c}
{\xe \v spstring.c\:sp_find_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_find_string (const {\b stringpool} *{\i sp}, const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool e ne restituisce la posizione, nel caso sia presente. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid position_find Posizione p della stringa, con 0<= p < MAX_DIM_STRING_POOL se str \'8F presente in sp; p=-1, altrimenti. Se sp e/o str sono NULL, restituisce -1. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la varibile di output e la inizializzo a -1 in caso di problemi durante la computazione\par
Dichiaro la variabile per l'iterazione su tutto l'array\par
Variabile di controllo per risultato comparazione\par
Controllo che sp ed str non siano NUL\par
Itero su tutta la dimensione possibile dell'array\par
Controllo se la posizione i-esima \'8F utilizzata\par
Comparo le stringhe e salvo il risultato\par
Controllo il risultato della comparazione\par
Se \'8F stata identificata la stringa salvo la posizione i-esima corrente\par
Forzo l'indice i a sforare sul valore di uscita dal ciclo for\par
Resituisco il valore di output, -1 se ci sono stati problemi e/o non \'8F stata trovata o >= pari alla posione della stringa cercata in sp \par
}}\par
}
{\xe \v sp_free\:spstring.c}
{\xe \v spstring.c\:sp_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_free ({\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dealloca lo spazio di memoria a cui sta puntando str. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verifica che il puntatore str non sia NULL\par
Verifica che sia stato allocato dello spazio in corrispondenza all'area di memoria puntata da str->char_array\par
Libera lo spazio puntato da str->char_array\par
Libera lo spazio puntato da str\par
Forza str a valere NULL dopo la deallocazione \par
}}\par
}
{\xe \v sp_free_stringpool\:spstring.c}
{\xe \v spstring.c\:sp_free_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_free_stringpool ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Libera la memoria e reinizializza la struct sringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
i - indice intero per ciclo for per la deallocazione delle stringe\par
Verifica che sp non sia NULL\par
Iterazione per liberare la memoria delle stringe salvate\par
Verifica che la posizione i-esima sia occupata da una stringa altrimenti evita istruzioni inutili\par
Rimuove la stringa decrementando used_counter e ponendo a 0 position[i] Per ogni iterazione la struttura stringpool \'8F consistente e coerente con le string rimosse e da rimuovere\par
Libero la memoria occupata dalla stringa i-esima\par
Operazione non necessaria se {\b sp_remove_string()} e {\b sp_free()} operano correttamente \par
}}\par
}
{\xe \v sp_get_allocated_size\:spstring.c}
{\xe \v spstring.c\:sp_get_allocated_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_get_allocated_size (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce la dimensione massima allocata per la stringa. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid allocated_size dimensione fisica allocata per str; se str \'8F 0, restituisce NULL \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variabile allocated_size di output\par
Verifica che str e str->char_array non siano NULL\par
imposta allocated_size al valore di str->allocated_size\par
In caso allocated_size \'8F 0 viene portato a NULL\par
Ritorna allocated_size che sar\'88 > 0 oppure NULL \par
}}\par
}
{\xe \v sp_get_string\:spstring.c}
{\xe \v spstring.c\:sp_get_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_get_string (const {\b stringpool} *{\i sp}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il puntatore alla stringa str che occupa la posizione pos all\'D5interno dello stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Se pos \'8F fuori da questo intervallo o se sp \'8F nullo, allora la funzione restituisce restituisce NULL.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore costante a struttura string pull \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero positivo che indica la posizione da controllare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid str_output puntatore a string in posizione pos, se 0<= pos < MAX_DIM_STRING_POOL; \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a NULL\par
Controllo come da specifica se sp \'8F NULL, se la posizione \'8F all'interno degli indici di stringpool\par
Controllo se la posizione richiesta \'8F utilizzata\par
In tal caso assozio l'indirizzo a cui punta stirngs[pos] alla variabile di output\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v sp_initialize_stringpool\:spstring.c}
{\xe \v spstring.c\:sp_initialize_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_initialize_stringpool ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inizializza una struttura Stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verifica se il puntatore sp non \'8F NULL\par
Imposta il counter degli slot utilizzati al valore di EMPTY_STRING_POOL\par
Imposta le posizioni al valore di UNUSED_SLOT rendendole tutte libere \par
}}\par
}
{\xe \v sp_isempty\:spstring.c}
{\xe \v spstring.c\:sp_isempty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_isempty (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se lo stringpool \'8F vuoto. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid isempty \'8F TRUE se sp \'8F vuoto, FALSE altrimenti; se sp \'8F NULL, restituisce FALSE \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a FALSE\par
Verifico che sp non sia NUL\par
Controllo se il numero di slot usati \'8F EMPTY_STRING_POOL\par
In caso affermativo, imposta isempty a TRUE, altrimenti rimane FALSE\par
Ritorno il valore di verit\'88 per sp VUOTO \par
}}\par
}
{\xe \v sp_isfull\:spstring.c}
{\xe \v spstring.c\:sp_isfull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_isfull (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se stringpool contiene gi\'88 il massimo numero di elementi consentiti. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid isfull \'8F TRUE se il numero di elementi presenti \'8F == MAX_DIM_STRING_POOL, FALSE altrimenti; se sp \'8F NULL, restituisce TRUE \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo se sp \'8F diverso da NULL\par
Controllo se il counter degli slot \'8F impotato alla dimensione massima di stringpool\par
Tutti gli slot sono usati, imposto isfull a TRUE\par
Caso in cui sp == NULL\par
Imposto come da specifica isfull a TRUE\par
Ritorno il valore di verita per sp PIENO \par
}}\par
}
{\xe \v sp_load_from_file\:spstring.c}
{\xe \v spstring.c\:sp_load_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_load_from_file ({\b stringpool} *{\i sp}, const {\b string}{\i fname})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Carica il contenuto del file di test fname nello o stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
L\'D5intera stringa letta su una riga sar\'88 un elemento dello stringpool. Inoltre conserva l'ordinamento ed il posizionamento originale delle stringhe pizzandole esattamene nella posizione originale.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{struttura string contenente il nome del file da leggere \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number_loaded_line il numero di righe lette e caricate \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output, la inizializzo a -1 in caso si incontrano problemi nel caricamento\par
Variabile di indice per ciclo for per caricamento righe\par
Dichiaro la variabile per la lettura "massima" di righe da file\par
Puntatore a file da leggere\par
Variabile per l'i-esimo slot letto da file\par
Varibile della posizione dell'i-esimo slot lett da file\par
array temporanei\par
tmp_slot_start_line per contenere l'inizio della stringa\par
tmp_slot_end_line per contenere la fine della riga, ovvero uno spazio un punto e virgola ed il carattere di nuova linea\par
Controllo che sp non sia NULL, e che il nome del file richiesto non sia vuoto o pari al solo spazio\par
Controllo che il file richiesto esista\par
In caso esiste viene ri-aperto\par
Imposto il numero di righe caricate a 0\par
Leggo la prima informazione del file che contiene il numero di stringhe salvate Ed imposto tale valore a number_slot.\par
Effettuo una iterazione su number_slot in modo da leggere le righe e salvarle\par
Se il puntarore all'i-esima itezione non \'8F NULL continuo\par
Se il puntatore all'i-esima iterazione non \'8F parti a EOF continuo\par
Effettuo una prima lettura della righa con fscanf prelevando posizione dello slot letto e la sua dimesione\par
Effettuo una seconda lettura con fgets leggendo la parte restante del testo basandomi sulla dimensione appena letta\par
Effettuo una terza lettura utile solo a far avanzare il puntatore, leggendo i 3 caratteri finali della stinga sufficenti a far trovare il puntare ad inizio riga alla prosssima iterazione\par
Aggiungo in sp lo slot lett con tmp_slot_start_line in posizione pos\par
Incremento la varibile che indica il numero di righe caricate\par
Contollo di sicurezza in caso il valore letto da pos non sia compatibile con la dimensione massima e minima contenibile in uno stringpool\par
Chiudo il file aperto\par
Restituisco il valore di ritorno pari al numero di righe lette \par
}}\par
}
{\xe \v sp_lower_case\:spstring.c}
{\xe \v spstring.c\:sp_lower_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_lower_case (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in minuscolo ciascun carattere della stringa in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid lower_output Puntatore a string contenente caratteri in minuscolo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro variabile di output\par
Variabile per lunghezza stringa\par
Variabile temporanea per carattere da porre in minuscolo\par
Variabile indice per ciclo for, per porre iterativamente tutti i caratteri in minuscolo\par
Controllo che str sia diverso da NULL\par
Controllo che sia diverso da NULL anche char_array\par
Calcolo la lungehzza della stringa, che potrebbe essere diversa dalla dimensione allocata per la stringa\par
Creo una nuova stringa vuota di dimensione della stringa in ingresso\par
Ciclo su tutta la lunghezza della stringa\par
Passo alla funzione tolower il carattere iesimo copiandolo in tmp_lower\par
Copio quindi tmp_lower nella posizione i-esima della string di output, passaggio inutile ma migliora la leggibilit\'88\par
Salvo il carattere di terminazine stringa in ultima+1 posizione\par
Ritorno la nuova stringa ottenuta ponendo in minuscolo ogni carattere \par
}}\par
}
{\xe \v sp_new_empty_string\:spstring.c}
{\xe \v spstring.c\:sp_new_empty_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_new_empty_string (int{\i len})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string vuota di dimensione len. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equivale alla stringa "" {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{intero maggiore uguale a zero \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid new_empty_string puntatore a struttura di tipo stringa \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variabile di output, puntatre a string, inzializzata a NULL nel caso len non \'8F >= 0\par
Verifica che len sia maggiore uguale a zero\par
Alloca la memoria per il puntatore new_empty_string, di dimensione SIZE_STRING_STRUCT\par
Imposta la memoria allocata al valore di len\par
Alloca lo spazio di dimensione len caratteria al puntatore char_array\par
Inserisce il carattere di terminazione nello spazio allocato\par
Ritorna l'indirizzo della struct string, \'8F NULL solo se len < 0 altrimenti punta ad una locazione di memoria valida\par
}}\par
}
{\xe \v sp_new_string\:spstring.c}
{\xe \v spstring.c\:sp_new_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_new_string (const char *{\i str})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string con contenuto pari a quello in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore costante a caratteri \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid new_string puntatore a string \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcolo e salvo la lunghezza della stringa passata, essa non contiene conto del carattere di terminazione \\0\par
Creo ed alloco una nuova stringa vuota di lunghezza (len_str+1)\par
Copio il contenuto di str in new_string->char_array\par
Ritorno il puntatore alla struct string \par
}}\par
}
{\xe \v sp_new_string_as_struct\:spstring.c}
{\xe \v spstring.c\:sp_new_string_as_struct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_new_string_as_struct (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una nuova string il cui contenuto \'8F uguale a quella in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid string_as_struct puntatore a string \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inizializzo la variabile di ritorno\par
associo alla variabile di ritorno il l'indirizzo della nuova string creata con sp_new_string\par
Ritorno l'indirizzo della nuova string \par
}}\par
}
{\xe \v sp_remove_string\:spstring.c}
{\xe \v spstring.c\:sp_remove_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_remove_string ({\b stringpool} *{\i sp}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rimuove e restituisce la stringa str all\'D5interno dello stringpool in posizione pos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se sp \'8F nullo, oppure se pos \'8F fuori dall\'D5intervallo pos, MAX_DIM_STRING_POOL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero che indica una posizione in stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid removed_str puntatore alla stringa rimossa dallo stringpool, oppure NULL se nessuna stringa \'8F presente in posizione pos \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inzializzo a NULL\par
Controllo se sp \'8F NULL o se pos sia all'interno del range di inidici di stringpool\par
Controllo se la posizione cercata contiene una Stringa Se la condizione \'8F soddisfatta salvo il suo indirizzo\par
Una volta salvato l'indirizzo della string rimossa, imposto la posizione come DISPONIBILE\par
Importo il counter degli slot utilizzati ad un valore inferiore\par
Ritorno la variabile di ouput contenente l'indirizzo della string rimossa \par
}}\par
}
{\xe \v sp_replace_string\:spstring.c}
{\xe \v spstring.c\:sp_replace_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_replace_string ({\b stringpool} *{\i sp}, int{\i pos}, {\b string} *{\i newstr})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sostituisce la stringa all\'D5interno dello stringpool in posizione pos, rimpiazzandola con str. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se str e/o sp sono nulli, oppure se pos \'8F fuori dall\'D5intervallo [pos, MAX_DIM_STRING_POOL[ {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newstr} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_relpaced TRUE se la sostituzione \'8F andata a buon fine, FALSE altrimenti \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo se sp \'8F NULL oppure se la posizione richiesta \'8F all'interno del range di indiici di stringpool\par
Controllo se la posizone richiesta \'8F utilizzata e se la nuova string \'8F diverso da NULL\par
Rimuvo la stringa richiesta in posizione POS, verranno decrementati il contatore ed impostato a libera la posizione pos\par
Aggiungo in posizionepos la nuova stringa, verrano reincrementati il contatore ed il valore di utilizzo dello slot\par
Salvo com'\'8F andata l'operazione nel valore di ritorno\par
Ritorno la variabile di output che indica se l'operazione \'8F andata a buon fine \par
}}\par
}
{\xe \v sp_save_to_file\:spstring.c}
{\xe \v spstring.c\:sp_save_to_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_save_to_file ({\b stringpool} *{\i sp}, const {\b string}{\i fname})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Salva il contenuto dello stringpool in un file di testo. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specificando il nome nel secondo paramentro fname. Ogni elemento sar\'88 salvato su una riga diversa.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number_writed_line con il numero di elementi scritti nel file oppure -1 in caso di errore. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a -1 in caso sia possibile effettuare alcuna operazione\par
Inizializzo la variabile indice per il ciclo di scruttura delle n linee\par
Inizializzo il puntatore al file per la lettura\par
Controllo che sp non sia null e che il nome del file su cui scrivere sia diverso da "" o " "\par
Credo il file richiesto e se l'operazione \'8F andata a buon fine continuo\par
Apro il file appena creato e se l'operazione va a buon fine continuo\par
Imposto il numero di linee scritte a 0 dato che stiamo per scrivere un numero di righe >= 0\par
Itero per l'intero numero massimo di posizione dell'array stringpool\par
controllo che lo slot i-esimo sia occupato da una string\par
In caso sia passata la condizione precedente, scrivo la riga i-esima basandomi sul pattern di scrittura e lettura PATTERN_READ_WRITE_LINE\par
Incremento il contatore del numero di righe scritte\par
In caso la riapertura del file non \'8F andata a buon fine imposto la variabile di output a -1 come da specifica\par
Chiudo il file aperto\par
Ritorno il valore di output che sar\'88 -1 se \'8F stato incontrato qualche problema, altrimento sar\'98 >= 0 ovvero il numero di linee scritte pari a sp_sizeof(<STRINPOOL>) \par
}}\par
}
{\xe \v sp_sizeof\:spstring.c}
{\xe \v spstring.c\:sp_sizeof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_sizeof (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il numero di stringhe in sp. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce 0 se lo stringpool \'8F vuoto; -1 se sp \'8F NULL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i \\return} \cell }{size_of_sp intero contenente il numero di elementi n>=0 presenti nello stringpool \cell }
{\row }
}
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo che sp sia diverso da NULL\par
In tal caso, associo alla variabile di output il numero di rigeh utilizzate che sar\'88 sempre n>=0 e 0 solo se sp \'8F vuoto\par
Nel caso sp sia NULL, associo alla variabile di output il valore -1\par
Ritorno il valore di Output \par
}}\par
}
{\xe \v sp_strcat\:spstring.c}
{\xe \v spstring.c\:sp_strcat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_strcat (const char *{\i str1}, const char *{\i str2})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla concatenazione di due stringhe in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a caratteri costante \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a caratteri costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid str_cat puntatore a string contenete una stringa equivalente a str1+str2 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiarro la variabile di ritorno\par
Dichiaro le variabili per le lunghezze rispettivamente di str2, str1 e string di output\par
Verifico che entrambe le stringhe non siano NULL\par
inizializzo le lunghezze di str1 e str2\par
Dichiaro la lunghezza complessiva della string concatenata sommando le lunghezze logiche di str1 e str2\par
Creo una nuova string vuota di lunghezza str_cat_len + 1 dato che sp_new_empty_string non tiene conto del carattere di terminazione\par
Copio in str_cat a partire dalla posizione 0 il contenuto di str1\par
Copio in str_cat a partire dalla posizione str_len_str1 la str2\par
Caso in cui almeno uno delle due string \'8F NULL ma non entrambe NULL\par
Controllo quale delle due string \'8F NULL\par
Nel caso fosse NULL la str1, creiamo una nuova string con il solo contenuto della str2\par
Nel caso fosse NULL la str2, creiamo una nuova string con il solo contenuto della str1\par
Ritorno il puntatore a string contenente le due stringhe concatenate \par
}}\par
}
{\xe \v sp_strcat_as_struct\:spstring.c}
{\xe \v spstring.c\:sp_strcat_as_struct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_strcat_as_struct (const {\b string} *{\i str1}, const {\b string} *{\i str2})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla conctaenazione delle due string in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a string costanti \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a string costanti \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid strcat_as_struct puntatore a string pari a str1+str2 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Verifico che entrmabe str1 e str2 non siano NULL\par
Controllo lo spazio allocato, se > 0 vuol dire che non sono vuote\par
Concateno le due stringhe utilizzando {\b sp_strcat()}\{\}\par
Caso in cui almeno una delle due ha dimensione 0 ma non entrambe di dimensione 0\par
Controllo quale delle due string \'8F di dimensione 0\par
Nel caso str1 \'8F di dimensione 0, creo una string con contenuto di str2\par
Nel caso str2 \'8F di dimensione 0, creo una string con contenuto di str1\par
Caso in cui str1 o str2 \'8F NULL ma non entrambe NULL\par
Verifico quale delle due \'8F NULL\par
Nel caso fosse srt1 NULL e str2 sia di dimensione mazziore di 0, creo una stringa con il contenuto di str2\par
Nel caso fosse srt2 NULL e str1 sia di dimensione mazziore di 0, creo una stringa con il contenuto di str1\par
Ritorno il valore di ritorno \par
}}\par
}
{\xe \v sp_strcmp\:spstring.c}
{\xe \v spstring.c\:sp_strcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_strcmp (const {\b string} *{\i str1}, const char *{\i str2})}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Confronta due stringhe e restituisce il relativo valore di verit\'88 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a string costante \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a carattere costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifequal che sar\'88 TRUE se str1 == str2; FALSE altrimenti \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro ed inizializzo variabile di output Booleana a FALSE\par
Dichiaro le variabili per la lunghezza delle due stringhe\par
Controllo che str1 e str->char array non siano NULL, str2 sar\'88 al massimo vuoto\par
inizializzo la lunghezza delle due stringhe\par
Verifico se hanno la stessa lunghezza, se sono lunghe uguali potrebbero anche essere identiche, altrimenti sono sicuramente diverse. Evito quindi di richiamere strcmp\par
Se sono lunghe uguali, verifico anche se sono identiche\par
Se sono anche identiche imposto ifequal a TRUE\par
Se non sono identiche imposto ifequal a FALSE\par
Se non sono lunghe uguali sono anche diverse, non faccio niente altro avendo ifequal inizializzato a FALSE\par
Ritorno il risultato che sar\'88 TRUE solo nel caso siano identiche str1 e str2 altrimenti restuir\'88 FALSE \par
}}\par
}
{\xe \v sp_strcpy\:spstring.c}
{\xe \v spstring.c\:sp_strcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_strcpy ({\b string} *{\i copy}, const char *{\i original}, int{\i offset})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia il contenuto della string original in copy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia la string partire dal carattere in posizione offset di copy. Se offset \'8F 0, allora la copia avviene dall\'D5inizio della stringa copy. La dimensione di copy deve essere pari o maggiore di quella di original. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i copy} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i original} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid copy puntatore a string che punga ad una copia della string original, assumendo che N >= M, a partire dalla posizione offset \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile per la lunghezza della stringa original\par
Verifico che copy non sia NULL\par
controllo che offset sia minore della grandezza di copy e che original sia diverso da NULL\par
Ottengo la dimensione di original\par
Controllo che copy sia maggiore o uguale alla dimensione di original\par
Copio il contenuto di original in copy dalla posizione offset in poi\par
Ritorno l'indirizzo di string copy \par
}}\par
}
{\xe \v sp_strlen\:spstring.c}
{\xe \v spstring.c\:sp_strlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_strlen (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcola e restituisce la lunghezza logica di una string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid strlen_current_str Intero n rappresentante la lunghezza con n>= 0; se str = NULL, allora n = 0 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro ed inizializzo la variabile di output a 0\par
Verifico che str e str->char_array non siano NULL e che la dimensione allocata non sia 0\par
Calcolo la lunghezza della stringa contenuta in str->char_array\par
Ritorna la linghezza della stringa, sar\'88 0 str o str->char_arrat sono NULL \par
}}\par
}
{\xe \v sp_upper_case\:spstring.c}
{\xe \v spstring.c\:sp_upper_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sp_upper_case (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in maiuscolo ciascun carattere della stringa in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid upper_output Puntatore a string contenente caratteri in maiuscolo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Variabile per lunghezza string di output\par
Variabile temporanea per carattere da porre in maiuscolo\par
Variabile indice per ciclo for, per trasformare in maiuscolo tutti i caratteri\par
Controllo che str nons ia NULL\par
Controllo che char_array non sia NULL\par
Ottengo la lunghezza di str e creo una nuova stringa vuota di lungehzza uguale a str\par
Ciclo su tutta la lungehzza si str\par
Ottengo i-esimo carattere di str e lo trasformo in maiuscolo\par
Salvo l'iesimo carattere maiuscolo nella string di output\par
Salvo il carattere di terminazine stringa in ultima+1 posizione\par
Ritorno la string di output con tutti i caratteri di str in maiuscolo \par
}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per il file Library/spstring.h\par \pard\plain 
{\tc\tcl2 \v Library/spstring.h}
{\xe \v Library/spstring.h}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per funzioni stringpool. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "bool.h"}\par
{\f2 #include "stringpool.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definizioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPSTRING_H_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funzioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_initialize_stringpool} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inizializza una struttura Stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_free_stringpool} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Libera la memoria e reinizializza la struct sringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_string} (const char *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string con contenuto pari a quello in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_empty_string} (int len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string vuota di dimensione len. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_get_allocated_size} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce la dimensione massima allocata per la stringa. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sp_free} ({\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dealloca lo spazio di memoria a cui sta puntando str. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_strlen} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcola e restituisce la lunghezza logica di una string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_strcmp} (const {\b string} *str1, const char *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Confronta due stringhe e restituisce il relativo valore di verit\'88 }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_new_string_as_struct} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una nuova string il cui contenuto \'8F uguale a quella in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcpy} ({\b string} *copy, const char *original, int offset)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia il contenuto della string original in copy. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcat} (const char *str1, const char *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla concatenazione di due stringhe in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_strcat_as_struct} (const {\b string} *str1, const {\b string} *str2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla conctaenazione delle due string in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_lower_case} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in minuscolo ciascun carattere della stringa in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_upper_case} (const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in maiuscolo ciascun carattere della stringa in ingresso. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_sizeof} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il numero di stringhe in sp. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_isempty} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se lo stringpool \'8F vuoto. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_isfull} (const {\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se stringpool contiene gi\'88 il massimo numero di elementi consentiti. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_find_string} (const {\b stringpool} *{\b sp}, const {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool e ne restituisce la posizione, nel caso sia presente. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_get_string} (const {\b stringpool} *{\b sp}, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il puntatore alla stringa str che occupa la posizione pos all\'D5interno dello stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_add_string} ({\b stringpool} *{\b sp}, {\b string} *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge la stringa puntata da str all\'D5interno dello stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_add_string_pos} ({\b stringpool} *{\b sp}, {\b string} *str, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge una string all\'D5interno dello stringpool in posizione pos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} * {\b sp_remove_string} ({\b stringpool} *{\b sp}, int pos)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rimuove e restituisce la stringa str all\'D5interno dello stringpool in posizione pos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b sp_replace_string} ({\b stringpool} *{\b sp}, int pos, {\b string} *newstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sostituisce la stringa all\'D5interno dello stringpool in posizione pos, rimpiazzandola con str. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_save_to_file} ({\b stringpool} *{\b sp}, const {\b string} fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Salva il contenuto dello stringpool in un file di testo. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sp_load_from_file} ({\b stringpool} *{\b sp}, const {\b string} fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Carica il contenuto del file di test fname nello o stringpool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bubble_sort} ({\b stringpool} *{\b sp})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina alfabeticamente gli elementi dello stringpool, applicando l\'D5algoritmo di bubble sort. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bin_search} (const {\b stringpool} *{\b sp}, const {\b string} str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool ordinato attraverso l\'D5algoritmo di ricerca binaria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b _sp_file_create} (const {\b string} *fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se esiste gi\'88 il file e se non esiste lo crea. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} {\b _sp_file_exist} (const {\b string} *fname)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se il file richiesto esiste e ne restituisce il valore di verit\'88 }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b _sp_map_array_stringpool} (const {\b stringpool} *{\b sp})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per funzioni stringpool. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Protitpi di funzioni per la manipolazione dei dati gestiti dalla libreria stringpool\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Autore:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Domenico Monaco, {\f2 domenico.monaco@kiuz.it} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2011 \par
}{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Licenza
\par}
{\tc\tcl2 \v Licenza}
GPLv2 {\f2 http://www.softwarelibero.it/gnudoc/gpl.it.txt} Per maggiori informazioni visitare il link o visualizzare il file LICENSE \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle definizioni\par
\pard\plain 
{\xe \v SPSTRING_H_\:spstring.h}
{\xe \v spstring.h\:SPSTRING_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPSTRING_H_}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Impedisce inclusioni multiple \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle funzioni\par
\pard\plain 
{\xe \v _sp_file_create\:spstring.h}
{\xe \v spstring.h\:_sp_file_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} _sp_file_create (const {\b string} *{\i fname})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se esiste gi\'88 il file e se non esiste lo crea. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifcreated boolean valore di verit\'88, TRUE se \'8F esiste gi\'88 o se non esiste ed \'8F stato Creato, FALSE se non esiste non \'8F stato possibile crearlo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Dichiaro il puntatore a file\par
Verifico che fname non sia nullo\par
Controllo se non esiste gi\'88 il file\par
Se non esiste cerco di crearlo\par
Se non si riesce a a crearlo imposto la variabile di output a FALSE\par
Altrimenti se sono riuscito* a crerlo imposto la variabile di output a TRUE\par
Chiudo il file aperto\par
Se esiste gi\'88 imposto la variabile outpt a TRUE\par
Ritorno il valore di output \par
}}\par
}
{\xe \v _sp_file_exist\:spstring.h}
{\xe \v spstring.h\:_sp_file_exist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} _sp_file_exist (const {\b string} *{\i fname})}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controlla se il file richiesto esiste e ne restituisce il valore di verit\'88 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifexist valore boolean FALSE se non esiste non \'8F possibile aprirlo in modalit\'88 di lettura, TRUE se esiste ed \'8F possibile aprirlo in modalit\'88 di lettura \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output inizializzandola a FAlSE\par
Dichiaro il puntatore a file\par
Verifico che fname non sia nullo\par
Controllo se \'8F possibile aprire il file richiesto in modalit\'88 di lettura\par
Se non \'8F possibile aprirlo imposto la variabile di output a FALSE\par
Altrimenti se \'8F possibile aprie il file imposto a TRUE la variabile di output\par
Chiudo il file\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v _sp_map_array_stringpool\:spstring.h}
{\xe \v spstring.h\:_sp_map_array_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int* _sp_map_array_stringpool (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro l'array di output\par
Dichiaro la variabile indice per il ciclo for e la variabile di posizione\par
Controllo che sp non sia NULL\par
Inizializzo lo spazio di memoria per l'array di outpu calcolato sulla dimensione di sp\par
Itero su tutte le possibili posizioni potenzialmente occupate in sp\par
Controllo se la i-esima posizione \'8F occupata\par
In caso sia occupata salvo in posizioni consecutive la posizione i-esima\par
Incremento la posizione del vettore di output solo se \'8F stato inserito qualcosa\par
Ritorno la varibile di ouput \par
}}\par
}
{\xe \v bin_search\:spstring.h}
{\xe \v spstring.h\:bin_search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bin_search (const {\b stringpool} *{\i sp}, const {\b string}{\i str})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool ordinato attraverso l\'D5algoritmo di ricerca binaria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ne restituisce la posizione, nel caso in cui str sia presente.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i \\return} \cell }{iffound pari alla posizione p della stringa, con 0<= p < MAX_DIM_STRING_POOL se str \'8F presente in sp; p=-1, altrimenti. Se sp o str sono nulli, restituisce -1. \cell }
{\row }
}
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Dichiaro la variabile indice per il ciclo while della ricerca binaria, rappresenta il numero di controll effettuati\par
Variabile di controllo per la ricerca della stringa cercata\par
Variabili per il calcolo dell'i-esima posizione da controlla come da definizione del bin_search\par
Puntatore ad array di interi contenere la mappa delle posizioni degli slot in stringpool\par
Controllo che sp e str non siano NULL, altrimenti salta salta e restituisce valore di errore -1\par
Calcolo e salvo la dimensione di sp\par
Se ha dimensione diversa da 0 \'8F possibile effettuare la ricerca\par
Ottengo la mappa delle posizione degli slot di sp\par
Imposto il parametro hight del binary serch alla dimensione di sp\par
Imposoto il parametro low del binary search a 1\par
Itero finch\'8F str_cmp non \'8F 0 ovvero \'8F stata identificata esattamente la stringa ricercata oppure se abbiamo gi\'88 controllato tutto gli slot\par
Calcolo mid su base della formula binary search\par
Controllo la strina in posizione mid, contrale rispetto [low, hight]\par
In base al risultato associo a low o hight un valore diverso ed incremento la variabile indice\par
Alla fine dll'iterazione controllo controllo se sia stata identificata o meno la stringa righesta\par
In caso sia concluso il ciclo senza trovare la stringa o non sia neanche iniziato, imposto il risultato a -1\par
In caso invece sia stata identificata la stringa resituisco la sua posizione\par
Ritorno il valore di ritorno che pu\'98 essere o la posizione p della strnga cercata o -1 in caso di errore \par
}}\par
}
{\xe \v bubble_sort\:spstring.h}
{\xe \v spstring.h\:bubble_sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bubble_sort ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina alfabeticamente gli elementi dello stringpool, applicando l\'D5algoritmo di bubble sort. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ordina effettuando un controllo su ogni coppia di elementi, partendo dal basso sceglie minore del confronto e lo porta verso l'alto. Ho usato la versione "corta" dell'algoritmo dover per ogni i-esimo ciclo assumiamo che l'elemento appena spostato \'8F gi\'88 in posizione corretta. Ho dovuto applicare un piccolo hack per poter fare l'ordinamento anche su array con elementi non contiugui e lasciare invariate le posizione vuote, in altri termini l'algoritmo ordina gli elementi solo sulle posizione attualmente utilizzare senza alterare la posizione degli slot vuoti.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro le variabili indici per i due cicli dell'algoritmo Bubble sort\par
Dichiaro la variabile per identificare se nell'i-esimo controllo \'8F necessario uno Switch degli slot\par
Dichiaro la variabile per memorizzare temporaneamente la string da sostituire\par
Dichiaro la variabile per mappare le posizioni degli slot\par
Controllo prima se sp non sia NULL ed in seguito se sp non \'8F VUOTO altrimenti non faccio null\par
Ottengo un array della mappa delle posizione dell'array. Dove ogni i-esima posione contiene la posizione reale dello slot. Ad esempio se esistono 4 elementi, ma il sp->position[3] \'8F vuoto mentre il sp->position[4] \'8F pieno il risultato sar\'88 un arrai del tipo [0->0,1->1,2->2,3->4]\par
Itero su due cicli for come da definizione dell'algoritmo\par
Il primo ciclo itera da 0 alla dimensione di sp, incrementando il puntatore\par
Il secondo ciclo itera dalla dimensione di sp meno 1,fino ad i, decrementando l'indice.\par
Ad ogni iterazione del primo ciclo for, il secndo ciclo for effettuera un passaggio in meno evitando di controllare elementi sicuramente gi\'88 in posizione corretta\par
La j esima posione \'8F quella corrente e dipende anche da i. Controlliamo le poszioni (j) e (j-1), identificando se sono o meno in ordine alfabetico utilizzando strcmp. Quindi ifswitch sar\'88 -1 l'elemento j deve essere spostato in posizione j-1 e viceversa\par
In questi cicli non mi devo preoccupare dei "buchi" nell'array stringpool dato che le iterazioni sono fatte sulla mappa dele posizione che \'8F un array continuo che ci permette di tradurre per ogni iterazione la reale posizione dello slot trattato\par
Controllo se bisogna scambiare gli elementi\par
Memorizzo temporanemente la stringa in posizione j\par
Rimpiazzo in posizione j la strin j-1\par
Rimpiazzo in posizione j-1 la stringa memorizzata precedentemente, ovvero quella in posizione j \par
}}\par
}
{\xe \v sp_add_string\:spstring.h}
{\xe \v spstring.h\:sp_add_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_add_string ({\b stringpool} *{\i sp}, {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge la stringa puntata da str all\'D5interno dello stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Viene aggiunta nella prima posizione libera. Nessuna operazione \'8F compiuta se str e/o sp sono nulli, oppure se sp \'8F pieno.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_added TRUE se l\'D5inserimento \'8F andato a buon fine, FALSE altrimenti. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di outpu inizializzandola a FALSE\par
Dichiaro la varibile di verit\'88 per la posizione libera\par
Variabile indice per ciclo while per la ricerca della posizione libera\par
Variabile\par
Controllo che sp ed str non siano NULL\par
Controllo se lo string pool non \'8F pieno\par
Ciclo per l'intero stringpool alla ricerca della prima posizione libera\par
Il ciclo continua finch\'8F check_free \'8F diverso da 1 e non abbiamo controllato tutte le posizini\par
Per ogni ciclo controllo se l'i-esima posizione \'8F libera\par
In caso affermativo, imposto check_free a 1\par
Provo quindi ad aggiungere la string in ingresso nella posizione libera appena trovata\par
Memoriazando il risutlato di tale operazione\par
Controllo se l'operazione di aggiunta della string in posizine iesima \'8F andata a buon fine\par
In caso affermativo imposto la variabile di output a TRUE\par
In caso negativo, riporto check_free a 0 permettendo di continuare a cercare un'altra posizione\par
Incremente il contatore iesimo\par
Ritorno il valore di verit\'88 per l'operazione di aggiunta string \par
}}\par
}
{\xe \v sp_add_string_pos\:spstring.h}
{\xe \v spstring.h\:sp_add_string_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_add_string_pos ({\b stringpool} *{\i sp}, {\b string} *{\i str}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aggiunge una string all\'D5interno dello stringpool in posizione pos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se str e/o sp sono nulli, se pos \'8F fuori dall\'D5intervallo 0<= pos < MAX_DIM_STRING_POOL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero che indica la posizione in cui aggiungere la string\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_added vale TRUE se l\'D5inserimento \'8F andato a buon fine, FALSE altrimenti. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output inizializzandola a FALSE\par
Controllo che sp e str non siano null e controllo che la posizione richiesta esista nello stringpool\par
Controllo che la posizione pos sia gi\'88 occupata, in tal caso libero la memoria\par
Inesrisco in strings[pos] il puntatore a str passata\par
positions e used_counter sono aggiornati solo se \'8F realmente presente in strings[pos] l'indirizzo voluto, altrimenti non aggiorna le variabili\par
L'assocciazione \'8F andata a buon fine, posso aggiornare le variabili positions, used_counter e is_added per l'output\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v sp_find_string\:spstring.h}
{\xe \v spstring.h\:sp_find_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_find_string (const {\b stringpool} *{\i sp}, const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cerca la stringa str all\'D5interno dello stringpool e ne restituisce la posizione, nel caso sia presente. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid position_find Posizione p della stringa, con 0<= p < MAX_DIM_STRING_POOL se str \'8F presente in sp; p=-1, altrimenti. Se sp e/o str sono NULL, restituisce -1. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la varibile di output e la inizializzo a -1 in caso di problemi durante la computazione\par
Dichiaro la variabile per l'iterazione su tutto l'array\par
Variabile di controllo per risultato comparazione\par
Controllo che sp ed str non siano NUL\par
Itero su tutta la dimensione possibile dell'array\par
Controllo se la posizione i-esima \'8F utilizzata\par
Comparo le stringhe e salvo il risultato\par
Controllo il risultato della comparazione\par
Se \'8F stata identificata la stringa salvo la posizione i-esima corrente\par
Forzo l'indice i a sforare sul valore di uscita dal ciclo for\par
Resituisco il valore di output, -1 se ci sono stati problemi e/o non \'8F stata trovata o >= pari alla posione della stringa cercata in sp \par
}}\par
}
{\xe \v sp_free\:spstring.h}
{\xe \v spstring.h\:sp_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sp_free ({\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dealloca lo spazio di memoria a cui sta puntando str. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verifica che il puntatore str non sia NULL\par
Verifica che sia stato allocato dello spazio in corrispondenza all'area di memoria puntata da str->char_array\par
Libera lo spazio puntato da str->char_array\par
Libera lo spazio puntato da str\par
Forza str a valere NULL dopo la deallocazione \par
}}\par
}
{\xe \v sp_free_stringpool\:spstring.h}
{\xe \v spstring.h\:sp_free_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sp_free_stringpool ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Libera la memoria e reinizializza la struct sringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
i - indice intero per ciclo for per la deallocazione delle stringe\par
Verifica che sp non sia NULL\par
Iterazione per liberare la memoria delle stringe salvate\par
Verifica che la posizione i-esima sia occupata da una stringa altrimenti evita istruzioni inutili\par
Rimuove la stringa decrementando used_counter e ponendo a 0 position[i] Per ogni iterazione la struttura stringpool \'8F consistente e coerente con le string rimosse e da rimuovere\par
Libero la memoria occupata dalla stringa i-esima\par
Operazione non necessaria se {\b sp_remove_string()} e {\b sp_free()} operano correttamente \par
}}\par
}
{\xe \v sp_get_allocated_size\:spstring.h}
{\xe \v spstring.h\:sp_get_allocated_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_get_allocated_size (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce la dimensione massima allocata per la stringa. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid allocated_size dimensione fisica allocata per str; se str \'8F 0, restituisce NULL \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variabile allocated_size di output\par
Verifica che str e str->char_array non siano NULL\par
imposta allocated_size al valore di str->allocated_size\par
In caso allocated_size \'8F 0 viene portato a NULL\par
Ritorna allocated_size che sar\'88 > 0 oppure NULL \par
}}\par
}
{\xe \v sp_get_string\:spstring.h}
{\xe \v spstring.h\:sp_get_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_get_string (const {\b stringpool} *{\i sp}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il puntatore alla stringa str che occupa la posizione pos all\'D5interno dello stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Se pos \'8F fuori da questo intervallo o se sp \'8F nullo, allora la funzione restituisce restituisce NULL.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore costante a struttura string pull \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero positivo che indica la posizione da controllare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid str_output puntatore a string in posizione pos, se 0<= pos < MAX_DIM_STRING_POOL; \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a NULL\par
Controllo come da specifica se sp \'8F NULL, se la posizione \'8F all'interno degli indici di stringpool\par
Controllo se la posizione richiesta \'8F utilizzata\par
In tal caso assozio l'indirizzo a cui punta stirngs[pos] alla variabile di output\par
Ritorno la variabile di output \par
}}\par
}
{\xe \v sp_initialize_stringpool\:spstring.h}
{\xe \v spstring.h\:sp_initialize_stringpool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sp_initialize_stringpool ({\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inizializza una struttura Stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par}
 Importa tipi di dato boolean {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par}
 Importa tipi di dato string e stringpool\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verifica se il puntatore sp non \'8F NULL\par
Imposta il counter degli slot utilizzati al valore di EMPTY_STRING_POOL\par
Imposta le posizioni al valore di UNUSED_SLOT rendendole tutte libere \par
}}\par
}
{\xe \v sp_isempty\:spstring.h}
{\xe \v spstring.h\:sp_isempty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_isempty (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se lo stringpool \'8F vuoto. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid isempty \'8F TRUE se sp \'8F vuoto, FALSE altrimenti; se sp \'8F NULL, restituisce FALSE \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a FALSE\par
Verifico che sp non sia NUL\par
Controllo se il numero di slot usati \'8F EMPTY_STRING_POOL\par
In caso affermativo, imposta isempty a TRUE, altrimenti rimane FALSE\par
Ritorno il valore di verit\'88 per sp VUOTO \par
}}\par
}
{\xe \v sp_isfull\:spstring.h}
{\xe \v spstring.h\:sp_isfull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_isfull (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce un valore booleno che indica se stringpool contiene gi\'88 il massimo numero di elementi consentiti. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid isfull \'8F TRUE se il numero di elementi presenti \'8F == MAX_DIM_STRING_POOL, FALSE altrimenti; se sp \'8F NULL, restituisce TRUE \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo se sp \'8F diverso da NULL\par
Controllo se il counter degli slot \'8F impotato alla dimensione massima di stringpool\par
Tutti gli slot sono usati, imposto isfull a TRUE\par
Caso in cui sp == NULL\par
Imposto come da specifica isfull a TRUE\par
Ritorno il valore di verita per sp PIENO \par
}}\par
}
{\xe \v sp_load_from_file\:spstring.h}
{\xe \v spstring.h\:sp_load_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_load_from_file ({\b stringpool} *{\i sp}, const {\b string}{\i fname})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Carica il contenuto del file di test fname nello o stringpool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
L\'D5intera stringa letta su una riga sar\'88 un elemento dello stringpool. Inoltre conserva l'ordinamento ed il posizionamento originale delle stringhe pizzandole esattamene nella posizione originale.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{struttura string contenente il nome del file da leggere \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number_loaded_line il numero di righe lette e caricate \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output, la inizializzo a -1 in caso si incontrano problemi nel caricamento\par
Variabile di indice per ciclo for per caricamento righe\par
Dichiaro la variabile per la lettura "massima" di righe da file\par
Puntatore a file da leggere\par
Variabile per l'i-esimo slot letto da file\par
Varibile della posizione dell'i-esimo slot lett da file\par
array temporanei\par
tmp_slot_start_line per contenere l'inizio della stringa\par
tmp_slot_end_line per contenere la fine della riga, ovvero uno spazio un punto e virgola ed il carattere di nuova linea\par
Controllo che sp non sia NULL, e che il nome del file richiesto non sia vuoto o pari al solo spazio\par
Controllo che il file richiesto esista\par
In caso esiste viene ri-aperto\par
Imposto il numero di righe caricate a 0\par
Leggo la prima informazione del file che contiene il numero di stringhe salvate Ed imposto tale valore a number_slot.\par
Effettuo una iterazione su number_slot in modo da leggere le righe e salvarle\par
Se il puntarore all'i-esima itezione non \'8F NULL continuo\par
Se il puntatore all'i-esima iterazione non \'8F parti a EOF continuo\par
Effettuo una prima lettura della righa con fscanf prelevando posizione dello slot letto e la sua dimesione\par
Effettuo una seconda lettura con fgets leggendo la parte restante del testo basandomi sulla dimensione appena letta\par
Effettuo una terza lettura utile solo a far avanzare il puntatore, leggendo i 3 caratteri finali della stinga sufficenti a far trovare il puntare ad inizio riga alla prosssima iterazione\par
Aggiungo in sp lo slot lett con tmp_slot_start_line in posizione pos\par
Incremento la varibile che indica il numero di righe caricate\par
Contollo di sicurezza in caso il valore letto da pos non sia compatibile con la dimensione massima e minima contenibile in uno stringpool\par
Chiudo il file aperto\par
Restituisco il valore di ritorno pari al numero di righe lette \par
}}\par
}
{\xe \v sp_lower_case\:spstring.h}
{\xe \v spstring.h\:sp_lower_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_lower_case (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in minuscolo ciascun carattere della stringa in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid lower_output Puntatore a string contenente caratteri in minuscolo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro variabile di output\par
Variabile per lunghezza stringa\par
Variabile temporanea per carattere da porre in minuscolo\par
Variabile indice per ciclo for, per porre iterativamente tutti i caratteri in minuscolo\par
Controllo che str sia diverso da NULL\par
Controllo che sia diverso da NULL anche char_array\par
Calcolo la lungehzza della stringa, che potrebbe essere diversa dalla dimensione allocata per la stringa\par
Creo una nuova stringa vuota di dimensione della stringa in ingresso\par
Ciclo su tutta la lunghezza della stringa\par
Passo alla funzione tolower il carattere iesimo copiandolo in tmp_lower\par
Copio quindi tmp_lower nella posizione i-esima della string di output, passaggio inutile ma migliora la leggibilit\'88\par
Salvo il carattere di terminazine stringa in ultima+1 posizione\par
Ritorno la nuova stringa ottenuta ponendo in minuscolo ogni carattere \par
}}\par
}
{\xe \v sp_new_empty_string\:spstring.h}
{\xe \v spstring.h\:sp_new_empty_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_new_empty_string (int{\i len})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string vuota di dimensione len. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equivale alla stringa "" {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{intero maggiore uguale a zero \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid new_empty_string puntatore a struttura di tipo stringa \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variabile di output, puntatre a string, inzializzata a NULL nel caso len non \'8F >= 0\par
Verifica che len sia maggiore uguale a zero\par
Alloca la memoria per il puntatore new_empty_string, di dimensione SIZE_STRING_STRUCT\par
Imposta la memoria allocata al valore di len\par
Alloca lo spazio di dimensione len caratteria al puntatore char_array\par
Inserisce il carattere di terminazione nello spazio allocato\par
Ritorna l'indirizzo della struct string, \'8F NULL solo se len < 0 altrimenti punta ad una locazione di memoria valida\par
}}\par
}
{\xe \v sp_new_string\:spstring.h}
{\xe \v spstring.h\:sp_new_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_new_string (const char *{\i str})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string con contenuto pari a quello in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore costante a caratteri \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid new_string puntatore a string \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcolo e salvo la lunghezza della stringa passata, essa non contiene conto del carattere di terminazione \\0\par
Creo ed alloco una nuova stringa vuota di lunghezza (len_str+1)\par
Copio il contenuto di str in new_string->char_array\par
Ritorno il puntatore alla struct string \par
}}\par
}
{\xe \v sp_new_string_as_struct\:spstring.h}
{\xe \v spstring.h\:sp_new_string_as_struct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_new_string_as_struct (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una nuova string il cui contenuto \'8F uguale a quella in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid string_as_struct puntatore a string \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inizializzo la variabile di ritorno\par
associo alla variabile di ritorno il l'indirizzo della nuova string creata con sp_new_string\par
Ritorno l'indirizzo della nuova string \par
}}\par
}
{\xe \v sp_remove_string\:spstring.h}
{\xe \v spstring.h\:sp_remove_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_remove_string ({\b stringpool} *{\i sp}, int{\i pos})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rimuove e restituisce la stringa str all\'D5interno dello stringpool in posizione pos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se sp \'8F nullo, oppure se pos \'8F fuori dall\'D5intervallo pos, MAX_DIM_STRING_POOL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{intero che indica una posizione in stringpool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid removed_str puntatore alla stringa rimossa dallo stringpool, oppure NULL se nessuna stringa \'8F presente in posizione pos \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inzializzo a NULL\par
Controllo se sp \'8F NULL o se pos sia all'interno del range di inidici di stringpool\par
Controllo se la posizione cercata contiene una Stringa Se la condizione \'8F soddisfatta salvo il suo indirizzo\par
Una volta salvato l'indirizzo della string rimossa, imposto la posizione come DISPONIBILE\par
Importo il counter degli slot utilizzati ad un valore inferiore\par
Ritorno la variabile di ouput contenente l'indirizzo della string rimossa \par
}}\par
}
{\xe \v sp_replace_string\:spstring.h}
{\xe \v spstring.h\:sp_replace_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_replace_string ({\b stringpool} *{\i sp}, int{\i pos}, {\b string} *{\i newstr})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sostituisce la stringa all\'D5interno dello stringpool in posizione pos, rimpiazzandola con str. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nessuna operazione \'8F compiuta se str e/o sp sono nulli, oppure se pos \'8F fuori dall\'D5intervallo [pos, MAX_DIM_STRING_POOL[ {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newstr} \cell }{puntatore a struttura string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid is_relpaced TRUE se la sostituzione \'8F andata a buon fine, FALSE altrimenti \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo se sp \'8F NULL oppure se la posizione richiesta \'8F all'interno del range di indiici di stringpool\par
Controllo se la posizone richiesta \'8F utilizzata e se la nuova string \'8F diverso da NULL\par
Rimuvo la stringa richiesta in posizione POS, verranno decrementati il contatore ed impostato a libera la posizione pos\par
Aggiungo in posizionepos la nuova stringa, verrano reincrementati il contatore ed il valore di utilizzo dello slot\par
Salvo com'\'8F andata l'operazione nel valore di ritorno\par
Ritorno la variabile di output che indica se l'operazione \'8F andata a buon fine \par
}}\par
}
{\xe \v sp_save_to_file\:spstring.h}
{\xe \v spstring.h\:sp_save_to_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_save_to_file ({\b stringpool} *{\i sp}, const {\b string}{\i fname})}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Salva il contenuto dello stringpool in un file di testo. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specificando il nome nel secondo paramentro fname. Ogni elemento sar\'88 salvato su una riga diversa.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sp} \cell }{puntatore a struttura stringpool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fname} \cell }{puntatore a struttura string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number_writed_line con il numero di elementi scritti nel file oppure -1 in caso di errore. \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output e la inizializzo a -1 in caso sia possibile effettuare alcuna operazione\par
Inizializzo la variabile indice per il ciclo di scruttura delle n linee\par
Inizializzo il puntatore al file per la lettura\par
Controllo che sp non sia null e che il nome del file su cui scrivere sia diverso da "" o " "\par
Credo il file richiesto e se l'operazione \'8F andata a buon fine continuo\par
Apro il file appena creato e se l'operazione va a buon fine continuo\par
Imposto il numero di linee scritte a 0 dato che stiamo per scrivere un numero di righe >= 0\par
Itero per l'intero numero massimo di posizione dell'array stringpool\par
controllo che lo slot i-esimo sia occupato da una string\par
In caso sia passata la condizione precedente, scrivo la riga i-esima basandomi sul pattern di scrittura e lettura PATTERN_READ_WRITE_LINE\par
Incremento il contatore del numero di righe scritte\par
In caso la riapertura del file non \'8F andata a buon fine imposto la variabile di output a -1 come da specifica\par
Chiudo il file aperto\par
Ritorno il valore di output che sar\'88 -1 se \'8F stato incontrato qualche problema, altrimento sar\'98 >= 0 ovvero il numero di linee scritte pari a sp_sizeof(<STRINPOOL>) \par
}}\par
}
{\xe \v sp_sizeof\:spstring.h}
{\xe \v spstring.h\:sp_sizeof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_sizeof (const {\b stringpool} *{\i sp})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce il numero di stringhe in sp. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce 0 se lo stringpool \'8F vuoto; -1 se sp \'8F NULL {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i \\return} \cell }{size_of_sp intero contenente il numero di elementi n>=0 presenti nello stringpool \cell }
{\row }
}
}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Controllo che sp sia diverso da NULL\par
In tal caso, associo alla variabile di output il numero di rigeh utilizzate che sar\'88 sempre n>=0 e 0 solo se sp \'8F vuoto\par
Nel caso sp sia NULL, associo alla variabile di output il valore -1\par
Ritorno il valore di Output \par
}}\par
}
{\xe \v sp_strcat\:spstring.h}
{\xe \v spstring.h\:sp_strcat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_strcat (const char *{\i str1}, const char *{\i str2})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla concatenazione di due stringhe in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a caratteri costante \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a caratteri costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid str_cat puntatore a string contenete una stringa equivalente a str1+str2 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiarro la variabile di ritorno\par
Dichiaro le variabili per le lunghezze rispettivamente di str2, str1 e string di output\par
Verifico che entrambe le stringhe non siano NULL\par
inizializzo le lunghezze di str1 e str2\par
Dichiaro la lunghezza complessiva della string concatenata sommando le lunghezze logiche di str1 e str2\par
Creo una nuova string vuota di lunghezza str_cat_len + 1 dato che sp_new_empty_string non tiene conto del carattere di terminazione\par
Copio in str_cat a partire dalla posizione 0 il contenuto di str1\par
Copio in str_cat a partire dalla posizione str_len_str1 la str2\par
Caso in cui almeno uno delle due string \'8F NULL ma non entrambe NULL\par
Controllo quale delle due string \'8F NULL\par
Nel caso fosse NULL la str1, creiamo una nuova string con il solo contenuto della str2\par
Nel caso fosse NULL la str2, creiamo una nuova string con il solo contenuto della str1\par
Ritorno il puntatore a string contenente le due stringhe concatenate \par
}}\par
}
{\xe \v sp_strcat_as_struct\:spstring.h}
{\xe \v spstring.h\:sp_strcat_as_struct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_strcat_as_struct (const {\b string} *{\i str1}, const {\b string} *{\i str2})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Crea una string ottenuta dalla conctaenazione delle due string in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a string costanti \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a string costanti \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid strcat_as_struct puntatore a string pari a str1+str2 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Verifico che entrmabe str1 e str2 non siano NULL\par
Controllo lo spazio allocato, se > 0 vuol dire che non sono vuote\par
Concateno le due stringhe utilizzando {\b sp_strcat()}\{\}\par
Caso in cui almeno una delle due ha dimensione 0 ma non entrambe di dimensione 0\par
Controllo quale delle due string \'8F di dimensione 0\par
Nel caso str1 \'8F di dimensione 0, creo una string con contenuto di str2\par
Nel caso str2 \'8F di dimensione 0, creo una string con contenuto di str1\par
Caso in cui str1 o str2 \'8F NULL ma non entrambe NULL\par
Verifico quale delle due \'8F NULL\par
Nel caso fosse srt1 NULL e str2 sia di dimensione mazziore di 0, creo una stringa con il contenuto di str2\par
Nel caso fosse srt2 NULL e str1 sia di dimensione mazziore di 0, creo una stringa con il contenuto di str1\par
Ritorno il valore di ritorno \par
}}\par
}
{\xe \v sp_strcmp\:spstring.h}
{\xe \v spstring.h\:sp_strcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b boolean} sp_strcmp (const {\b string} *{\i str1}, const char *{\i str2})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Confronta due stringhe e restituisce il relativo valore di verit\'88 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str1} \cell }{puntatore a string costante \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str2} \cell }{puntatore a carattere costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ifequal che sar\'88 TRUE se str1 == str2; FALSE altrimenti \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro ed inizializzo variabile di output Booleana a FALSE\par
Dichiaro le variabili per la lunghezza delle due stringhe\par
Controllo che str1 e str->char array non siano NULL, str2 sar\'88 al massimo vuoto\par
inizializzo la lunghezza delle due stringhe\par
Verifico se hanno la stessa lunghezza, se sono lunghe uguali potrebbero anche essere identiche, altrimenti sono sicuramente diverse. Evito quindi di richiamere strcmp\par
Se sono lunghe uguali, verifico anche se sono identiche\par
Se sono anche identiche imposto ifequal a TRUE\par
Se non sono identiche imposto ifequal a FALSE\par
Se non sono lunghe uguali sono anche diverse, non faccio niente altro avendo ifequal inizializzato a FALSE\par
Ritorno il risultato che sar\'88 TRUE solo nel caso siano identiche str1 e str2 altrimenti restuir\'88 FALSE \par
}}\par
}
{\xe \v sp_strcpy\:spstring.h}
{\xe \v spstring.h\:sp_strcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_strcpy ({\b string} *{\i copy}, const char *{\i original}, int{\i offset})}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia il contenuto della string original in copy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copia la string partire dal carattere in posizione offset di copy. Se offset \'8F 0, allora la copia avviene dall\'D5inizio della stringa copy. La dimensione di copy deve essere pari o maggiore di quella di original. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i copy} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i original} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid copy puntatore a string che punga ad una copia della string original, assumendo che N >= M, a partire dalla posizione offset \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile per la lunghezza della stringa original\par
Verifico che copy non sia NULL\par
controllo che offset sia minore della grandezza di copy e che original sia diverso da NULL\par
Ottengo la dimensione di original\par
Controllo che copy sia maggiore o uguale alla dimensione di original\par
Copio il contenuto di original in copy dalla posizione offset in poi\par
Ritorno l'indirizzo di string copy \par
}}\par
}
{\xe \v sp_strlen\:spstring.h}
{\xe \v spstring.h\:sp_strlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sp_strlen (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calcola e restituisce la lunghezza logica di una string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid strlen_current_str Intero n rappresentante la lunghezza con n>= 0; se str = NULL, allora n = 0 \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro ed inizializzo la variabile di output a 0\par
Verifico che str e str->char_array non siano NULL e che la dimensione allocata non sia 0\par
Calcolo la lunghezza della stringa contenuta in str->char_array\par
Ritorna la linghezza della stringa, sar\'88 0 str o str->char_arrat sono NULL \par
}}\par
}
{\xe \v sp_upper_case\:spstring.h}
{\xe \v spstring.h\:sp_upper_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string}* sp_upper_case (const {\b string} *{\i str})}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restituisce una nuova stringa ottenuta ponendo in maiuscolo ciascun carattere della stringa in ingresso. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametri:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{puntatore a string costante \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Restituisce:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid upper_output Puntatore a string contenente caratteri in maiuscolo \par
}}{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dichiaro la variabile di output\par
Variabile per lunghezza string di output\par
Variabile temporanea per carattere da porre in maiuscolo\par
Variabile indice per ciclo for, per trasformare in maiuscolo tutti i caratteri\par
Controllo che str nons ia NULL\par
Controllo che char_array non sia NULL\par
Ottengo la lunghezza di str e creo una nuova stringa vuota di lungehzza uguale a str\par
Ciclo su tutta la lungehzza si str\par
Ottengo i-esimo carattere di str e lo trasformo in maiuscolo\par
Salvo l'iesimo carattere maiuscolo nella string di output\par
Salvo il carattere di terminazine stringa in ultima+1 posizione\par
Ritorno la string di output con tutti i caratteri di str in maiuscolo \par
}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Riferimenti per il file Library/stringpool.h\par \pard\plain 
{\tc\tcl2 \v Library/stringpool.h}
{\xe \v Library/stringpool.h}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per tipi di dati stringpool. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Composti\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b string}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b stringpool}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definizioni\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STRINGPOOL_H_}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNUSED_SLOT}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USED_SLOT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EMPTY_STRING_POOL}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_DIM_STRING_POOL}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SIZE_STRING_STRUCT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_CHAR_STRING_LOAD_FROM_FILE}\~ 255\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PATTERN_READ_WRITE_LINE}\~ "%d , %d , %s ;\\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PATTERN_READ_WRITE_START_LINE_SHORT}\~ "%d , %d ,"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PATTERN_READ_WRITE_END_LINE_SHORT}\~ " ;\\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PATTERN_READ_WRITE_INIT}\~ "%d ;\\n"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrizione dettagliata\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header per tipi di dati stringpool. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definizioni di variabili e tipi di dato per la libreria stringpool\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Autore:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Domenico Monaco, {\f2 domenico.monaco@kiuz.it} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2011 \par
}{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Licenza
\par}
{\tc\tcl2 \v Licenza}
GPLv2 {\f2 http://www.softwarelibero.it/gnudoc/gpl.it.txt} Per maggiori informazioni visitare il link o visualizzare il file LICENSE \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentazione delle definizioni\par
\pard\plain 
{\xe \v EMPTY_STRING_POOL\:stringpool.h}
{\xe \v stringpool.h\:EMPTY_STRING_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EMPTY_STRING_POOL\~ 0}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard per l'identificazione del numero di stringhe contenute in stringpool per identificarlo come Vuoto. Deve contenere interi, si consiglia EMPTY_STRING_POOL 0. \par
}}
{\xe \v MAX_CHAR_STRING_LOAD_FROM_FILE\:stringpool.h}
{\xe \v stringpool.h\:MAX_CHAR_STRING_LOAD_FROM_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_CHAR_STRING_LOAD_FROM_FILE\~ 255}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Valore massimo per l'allocazione dell'array di memorizzazione della stringa da file \par
}}
{\xe \v MAX_DIM_STRING_POOL\:stringpool.h}
{\xe \v stringpool.h\:MAX_DIM_STRING_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_DIM_STRING_POOL\~ 10}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Numero massimo di stringhe che stringpool pu\'98 contenere. Identifica anche lo stato di stringpool Pieno. Deve contenere un'intero maggiore di 0, si consiglia MAX_DIM_STRING_POOL 10. \par
}}
{\xe \v PATTERN_READ_WRITE_END_LINE_SHORT\:stringpool.h}
{\xe \v stringpool.h\:PATTERN_READ_WRITE_END_LINE_SHORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PATTERN_READ_WRITE_END_LINE_SHORT\~ " ;\\n"}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pattern parziale finale per la scirttura su file \par
}}
{\xe \v PATTERN_READ_WRITE_INIT\:stringpool.h}
{\xe \v stringpool.h\:PATTERN_READ_WRITE_INIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PATTERN_READ_WRITE_INIT\~ "%d ;\\n"}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pattern completo per la lettura/scrittura della riga iniziale su file \par
}}
{\xe \v PATTERN_READ_WRITE_LINE\:stringpool.h}
{\xe \v stringpool.h\:PATTERN_READ_WRITE_LINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PATTERN_READ_WRITE_LINE\~ "%d , %d , %s ;\\n"}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pattern completo per la lettura/scrittura su file \par
}}
{\xe \v PATTERN_READ_WRITE_START_LINE_SHORT\:stringpool.h}
{\xe \v stringpool.h\:PATTERN_READ_WRITE_START_LINE_SHORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PATTERN_READ_WRITE_START_LINE_SHORT\~ "%d , %d ,"}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pattern parziale iniziale per la scrittura su file \par
}}
{\xe \v SIZE_STRING_STRUCT\:stringpool.h}
{\xe \v stringpool.h\:SIZE_STRING_STRUCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SIZE_STRING_STRUCT\~ 1}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dimensione di base per l'allocazione della struttura string \par
}}
{\xe \v STRINGPOOL_H_\:stringpool.h}
{\xe \v stringpool.h\:STRINGPOOL_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STRINGPOOL_H_}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Impedisce inclusioni multiple \par
}}
{\xe \v UNUSED_SLOT\:stringpool.h}
{\xe \v stringpool.h\:UNUSED_SLOT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNUSED_SLOT\~ 0}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard per l'identificazione degli slot Liberi Deve contenere interi, si consiglia UNUSED_SLOT 0 \par
}}
{\xe \v USED_SLOT\:stringpool.h}
{\xe \v stringpool.h\:USED_SLOT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USED_SLOT\~ 1}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard per l'identificazione degli slot Occupati Deve contenere interi, si consiglia USED_SLOT 1 \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Indice\par 
\pard\plain 
{\tc \v Indice}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}